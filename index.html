<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SAT Solver Template: SatSolverTemplate</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SAT Solver Template
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SatSolverTemplate </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a>SAT solver template for a course (TP) at INSA Toulouse.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Setup</h1>
<p>For this course, you need a modern C++ compiler that supports C++20. I recommend using <code>g++</code> or <code>clang</code>. <code>MSVC</code> should also work, but I haven't tested it yet. Furthermore, you need <code>cmake</code> (at least version 3.14). And finally, I recommend that you install one of the following libraries on your system: <code>libdw</code> (<code>libdw-dev</code>), <code>libdwarf</code> (<code>libdwarf-dev</code>). These are not necessary but help producing meaningful stacktraces which makes debugging easier. I have no idea whether these libraries are available for Windows...</p>
<p>All the remaining dependencies are handled by cmake.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Configure the Project</h1>
<p>I recommend that you use a C++ IDE like CLion or an editor like VS-Code. Both have cmake integration making your life a lot easier. If you like suffering and plan on developing using a basic editor, fret naught, it's not that complicated, actually. The CMake project automatically configures all targets (the executables that you will run later) for you. The following targets should be configured automatically:</p><ul>
<li>all_tests (runs all unit tests)</li>
<li>test_basic_structures (runs only the tests for the basic structures like Variable and Literal)</li>
<li>test_clause (runs only the tests for the Clause class)</li>
<li>test_solver (runs only the tests for the principal member functions of the solver class)</li>
<li>test_unit_propagation (runs only the tests for the unit propagation)</li>
</ul>
<p>If you want to add other executables (e.g. a 'solve' executable that reads a problem and tries to solve it), then you can add them in the main project file. For example, you could create <code>solve.cpp</code> file. In order to generate a build target, you need to rerun CMake.</p>
<p>If you want to add a test, then you should add <code>test_&lt;name of your test&gt;.cpp</code> in the <code>Tests</code>-directory. Again you need to rerun CMake for the target to be generated.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
CLion</h2>
<p>Simply clone the project and open the folder as project with CLion. It should do everything for you. On first launch CLion will probably ask you to create a CMake profile. Usually the proposed 'Debug' config is exactly what you want. You can additionally create a 'Release' config by clicking on the + icon above the Debug config and it will most likely create the appropriate release config automatically for you. When you're done just click ok. You can always add more configs later on.</p>
<p>CLion should now automatically load the CMake project and configure all targets for you. You can select which target to build on the top right of your screen. All the targets mentioned above should be available.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
VS-Code</h2>
<p>You need to install the official Microsoft <code>CMake Tools</code> extension. Clone the project and open the folder with VS-Code. If asked to trust the project, click on trust. VS-Code will probably ask you to select a 'Kit' for the project. Here you select your C++-compiler. Once done, the CMake project should automatically load.</p>
<p>Select the <code>CMake Tools</code> extension sidebar on the left. Depending on you VSC configuration, you should see three tabs (usually on the left). In the 'Project Status' tab you should see six drop-down items:</p><ul>
<li>Folder: We don't care</li>
<li>Configure: Here you can select your compiler and the build configuration (Debug / Release)</li>
<li>Build: We don't care</li>
<li>Test: We don't care</li>
<li>Debug: Here you can select a target and launch it with the debugger attached</li>
<li>Launch: Here you can select a target and launch it in the console</li>
</ul>
<p>Under the 'Project Outline' tab you should see all libraries and executables of the project. The initial targets listed above should be visible here. You can alternatively build, launch and debug from here by right-clicking on an executable and selecting the desired action. Or you simply use the integrated terminal and launch the executable manually (once built, they should be in you build folder).</p>
<p>If you want to launch / debug an executable from VS-Code while passing command line arguments, you need to add them to the <code>.vscode/launch.json</code>. Open the file and add the arguments as comma separated strings to the <code>args</code> variable. There are three configurations in the <code>launch.json</code>:</p><ul>
<li><code>Run current target (gdb)</code>: Use this config if you're on Linux and use <code>g++</code> as compiler</li>
<li><code>Run current target (lldb)</code>: Use this config if you're on MacOS or on Linux and use <code>clang</code> as compiler</li>
<li><code>Run current target (msvc)</code>: Use this config if you're on Windows</li>
</ul>
<p>In any case, once you opened any code file, press F5 to run the current <em>Launch target</em>. This is the target that is selected in the <code>CMake Tools</code> tab in the sidebar under <code>Project Status/Launch</code>.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Manually using CMake</h2>
<p>If you don't want to use one of the aforementioned methods, you can manually configure the project and work with any editor of your choice.</p><ol type="1">
<li>Clone the repo and change into the folder</li>
<li>Create a build folder for each build config (Debug / Release, e.g. build_dbg / build_rel)</li>
<li>To configure the project run the following command (replace &lt;...&gt;): <div class="fragment"><div class="line">cmake -S . -B &lt;path to you build directory&gt; -DCMAKE_BUILD_TYPE=&lt;release/debug&gt;</div>
</div><!-- fragment --> CMake should run without error. Towards the end of the output you should see a list with the targets mentioned above. You can manually specify the compiler using the flag <code>-DCMAKE_CXX_COMPILER=&lt;the compiler of your choice&gt;</code></li>
<li>To build a target run the following command <div class="fragment"><div class="line">cmake --build &lt;path to your build folder&gt; -t &lt;name of the target&gt; -j &lt;number of processors to use&gt;</div>
</div><!-- fragment --> If the build was successful, you can launch the executable directly from the terminal. For example, if you built the target <code>test_clause</code> then you execute the following command: <div class="fragment"><div class="line">&lt;name of your build folder&gt;/Tests/test_clause</div>
</div><!-- fragment --></li>
<li>Whenever you add new target (e.g. the solve executable) make sure to rerun CMake (just retype the command in 3.)</li>
</ol>
<h1><a class="anchor" id="autotoc_md6"></a>
Project Structure</h1>
<p>The goal of this course is to develop a simple SAT-solver in C++. Don't worry if you're not very familiar with this language. This template should help you focus on the logic of the solver instead of worrying about implementation details. On the other hand, if you're a C++ pro then feel free to deviate from the template as you see fit.</p>
<p>You can find a doxygen generated documentation of all the structures <a href="https://timmifixedit.github.io/SatSolverTemplate/files.html">here</a>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Implementation of the Solver</h2>
<p>The solver will be developed as a C++-class in <code><a class="el" href="Solver_8hpp.html" title="Contains the main solver class.">Solver/Solver.hpp</a>(cpp)</code>. As a reminder, in C and C++ we usually <em>declare</em> functions and classes in the header file. A declaration involves only the function signatures and the class members. The actual <em>implementation</em> will be done in the <code>.cpp</code> file. Exceptions are template classes and functions, but normally you don't need to worry about that too much. To facilitate the implementation of the solver, we'll make use of the following constructs:</p><ul>
<li>Variable and Literal (in <code><a class="el" href="basic__structures_8hpp.html" title="Contains the basic structures variable and literal.">Solver/basic_structures.hpp</a>(cpp)</code>)</li>
<li>Clause (in <code><a class="el" href="Clause_8hpp.html" title="Contains the class Clause that consists of one or more literals.">Solver/Clause.hpp</a>(cpp)</code>)</li>
</ul>
<p>Additionally, I already implemented some helping constructs in <code>Solver/util</code> as well as functions for reading and writing SAT-formulas in <code><a class="el" href="inout_8hpp.html" title="Contains functions for reading and writing dimacs format. Also contains printing utilities for basic ...">Solver/inout.hpp</a>(cpp)</code>.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Unit Tests using GTest</h2>
<p>Under the <code>Tests</code> directory I implemented some unit tests using the <a href="https://google.github.io/googletest/">GTest framework</a> for the different structures that you will implement. They are by no means exhaustive but should give you some idea of how to use the structures and what they should do. Feel free to add further testcases if you wish (the language is pretty straightforward). The tests are grouped by implementation task (tests for the basic structures, for the clauses and for the solver itself). Also, I included 4 test cases for the unit propagation algorithm. Each of those test groups compiles to a separate testing executable. This means you can run them separately. Alternatively, you can run all tests using the <code>all_tests</code> target. Initially, all tests will fail since the implementations of all methods are missing. If you want to add a new test executable, make sure to respect the naming convention <code>test_&lt;name of your test&gt;.cpp</code>. Or you can simply add test cases in the test files already present.</p>
<p>You're implementation should pass all unit tests with the exception of the tests in <code>test_clause.cpp</code> (if you plan on implementing the unit propagation using counters, you don't need to implement a Clause-class). Especially the unit propagation tests will be used to determine your grade for this TP.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Exercises</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
1. Basic Structures</h2>
<p>First we will focus on the implementation of the structures that we use for representing the problem: Variable and Literal. A Variable is more or less just an ID identifying a variable in the SAT-formula. A Literal represents one of two values that a variable can take. Since the variables are boolean, the only possible values for let's say a variable <code>x</code> are <code>x</code> and <code>¬x</code>.</p>
<p>Follow the documentation in <code><a class="el" href="basic__structures_8hpp.html" title="Contains the basic structures variable and literal.">Solver/basic_structures.hpp</a></code> to implement all the necessary functions. Remember that the implementation goes in the file <code>Solver/basic_structures.cpp</code> (simply replace all the method bodies).</p>
<p>Test your implementation by building and running the test target <code>test_basic_structures</code>.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
2. Clause</h2>
<p>Next we need a structure to represent clauses. This can be a simple list that holds a variable number of literals. I recommend using <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> from the header <code>&lt;vector&gt;</code>. This is a variable sized array that holds elements in a contiguous block of memory which makes it very efficient in loops and also provides efficient random access. Now you have two choices:</p><ol type="1">
<li>If you want to implement the unit propagation algorithm using counters, then you don't need to implement anything. Simply use <code>std::vector&lt;Literal&gt;</code> as your clause. I recommend that you create a type alias as follows <div class="fragment"><div class="line">{c++}</div>
<div class="line">  using Clause = std::vector&lt;Literal&gt;;</div>
</div><!-- fragment --> This alias is actually necessary because the tests depend on it. On top of that, it makes your code mor readable. If you choose this option, you can simply delete the class <code>Clause</code> in <code><a class="el" href="Clause_8hpp.html" title="Contains the class Clause that consists of one or more literals.">Solver/Clause.hpp</a></code> and remove all the implementations from <code>Solver/Clause.cpp</code> (if you delete the <code>.cpp</code> file, you need to reload CMake). In this case we don't care that the unit tests for the clause class don't work. You can simply delete <code>Tests/test_clause.cpp</code> and reload CMake.</li>
<li>If you want to implement the more efficient unit propagation using watch literals, I recommend that you use the <code>Clause</code>-class already declared in <code><a class="el" href="Clause_8hpp.html" title="Contains the class Clause that consists of one or more literals.">Solver/Clause.hpp</a></code>. Again, you will need to implement all functions in the corresponding <code>.cpp</code> file. The class is designed to be immutable. You are not supposed to change a SAT-<code>Clause</code> once it has been declared (you cannot add or remove literals). Follow the documentation already provided and test your code using the test target <code>test_clause</code>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md12"></a>
Solver</h2>
<p>No we get to the actual solver. Depending on the approach that you choose for the unit propagation you need to organize your Clauses and Literals. In any case, you additionally need to keep track of the current variable assignment, i.e. the <em>model</em>. This means that you need to save the truth value of every variable. A variable can either be <code>true</code>, <code>false</code> or <code>unassigned</code>. Independently of your unit propagation algorithm you need to be able to efficiently look up clauses by literals. Since you don't want to have multiple copies of the same clauses in your solver, you need to organize them using pointers. I recommend that you use <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> for that purpose. I already made the type aliases <code>ClausePointer</code> and <code>ConstClausePointer</code> for you in <code><a class="el" href="Solver_8hpp.html" title="Contains the main solver class.">Solver/Solver.hpp</a></code>. The advantage with <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> is that you don't need to worry about memory management.</p>
<ol type="1">
<li>Start by declaring all your data structures within the solver class (organize your clauses, unit literals and model etc...). The start with the constructor and methods like <code>val</code>, <code>satisfied</code>, <code>falsified</code>, ... You can run the test target <code>test_solver</code> even if you haven't yet finished implementing all methods.</li>
<li>Implement the <b>unit propagation</b> using the algorithm of you choice. This function is crucial for the SAT-solver, make sure it works as intended! Verify your implementation using the simple unit propagation test cases in <code>test_solver</code> and using the extra tests in <code>test_unit_propagation</code>.</li>
<li>Once your unit propagation works, you can finally implement the actual solve loop. Start with the DPLL algorithm. You will see that at some point you will choose the next variable to decide. You can use the <code>FirstVariable</code> heuristic from <code><a class="el" href="heuristics_8hpp.html" title="Contains different branching heuristics.">Solver/heuristics.hpp</a></code>. This is probably the simplest heuristic there is (and it is not very good). You can also write your own heuristic (now or later). You don't need to use this class and instead implement your heuristic however you like (for example directly inside the solver). The advantage of an external heuristic class with a well-defined interface is that you can easily replace it later with something more powerful.</li>
<li>To test your solver, write a simple executable <code>solve.cpp</code> that you place in the main directory. You first need to load a problem using the functions from <code>Solver/input.hpp</code>. Then you configure your solver, run the search and finally print the result. When printing your solver output, please respect the following rules:<ul>
<li>If the instance is UNSAT, print the word <code>UNSAT</code>.</li>
<li>If the instance is SAT, print the solution (all unit literals) in DIMACS format. Use the function <code><a class="el" href="namespacesat_1_1inout.html#a376589301e45f91e85298fa8fecdc291">sat::inout::to_dimacs</a></code> from ´Solver/inout.hpp´ and <a href="https://en.cppreference.com/w/cpp/io/cout"><code>std::cout</code></a>.</li>
<li>Make sure to respect these rules. You can print other stuff as you like as long as you prepend it with the character <code>c</code> to mark the line as comment.</li>
</ul>
</li>
<li>Once your DPLL search works you can:<ul>
<li>Implement a better value selection heuristic. If you used the <code>FirstVariable</code> heuristic in step 4 I recommend that you use this interface to create your own heuristic. Simply make a copy of <code>FirstVariable</code> in <code><a class="el" href="heuristics_8hpp.html" title="Contains different branching heuristics.">Solver/heuristics.hpp</a></code> and don't forget the implementation in the <code>.cpp</code> file. You could for example try implementing a heuristic that randomly selects an unassigned variable (there is a random number generator in <code><a class="el" href="random_8hpp.html" title="Contains an easy-to-use random number generator.">Solver/util/random.hpp</a></code>).</li>
<li>Implement restarting.</li>
<li>Implement clause learning and ultimately CDCL search. This algorithm is much more powerful than DPLL and should be able to resolve even big problem instances.</li>
</ul>
</li>
</ol>
<p>Note: You will get a good grade if you manage to correctly implement DPLL, no need to do all the tasks in 5. But you will get an even better grade if you put in some extra work :).</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Grading</h1>
<p>You should hand in a working solver leveraging at least the DPLL algorithm. Create a simple executable as described in step 4 above. Your executable needs to accept at least one command line argument (the path to the problem instance). If the solver accepts more arguments, please document them and give them meaningful default values. The solver needs to be callable with just the problem instance. When printing your solution, respect the rules also detailed in step 4. If you don't, you will lose points!</p>
<p>Your solver will be run on a set of different problem instances of different difficulties (the ones under <code>eval</code>). The more instance you can solve, the better. Your solver will be given a timeout of 2 minutes for each instance. When running your solver, your code will be built in release mode (with all optimizations) to make it faster. If you want to see how fast your solver can go, you too should build in release mode.</p>
<p>Your solver should at least be able to solve the medium instances (both SAT and UNSAT). If it can solve the harder once, that's great. But above all, your solver should not crash. Make sure to write proper and safe code! </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
